# Стоит разделить для начала неявную и явную (implicit и explicit) передачу блока в метод. 
# Да, в Руби блок можно передать в метод по-разному.
# Самый стандартный и часто используемый вариант - неявная передача блока и вызов посредством yield.
# Неявная передача блоков осуществляется путем вызова ключевого слова yield в методе. 
# Ключевое слово yield является специальным. Оно находит и вызывает переданный блок, 
# поэтому не нужно добавлять блок в список аргументов, принимаемых методом.

# Поскольку Ruby допускает неявную передачу блока, вы можете вызывать все методы с блоком. 
# Если метод не вызывает yield, то блок игнорируется:
"foo bar baz".split() { p "block!" }
=> ["foo", "bar", "baz"]

# Если же в методе есть вызов посредством yield, 
# то будет выполнен поиск переданного блока и его вызов с переданным аргументом:

[1, 2, 3].each() { |n| puts n }

def each
  return to_enum(:each) unless block_given?
 
  i = 0
  while i < size
    yield at(i)
    i += 1
  end
end

# Это позволяет передавать блоки неявно, но не позволяет коду обращаться к блоку напрямую, 
# поскольку он не хранится в переменной (и, как следствие, не инстанциируется в объект класса Proc. 
# Да, друзья, блоки - не объекты). Учтите, что yield вылетит с ошибкой, если блок не передан, поэтому использовать
# Guard clause вместе с block_given? - a must.

# Явная передача блока:
# Мы можем явно принять блок в методе, добавив его в качестве аргумента с помощью параметра 
# с амперсандом (обычно он называется &block). Поскольку блок теперь явный, 
# мы можем использовать метод #call непосредственно на результирующем объекте 
# (переданный блок тогда инстанциируется в объект класса Proc), а не полагаться на yield.

# Аргумент &block не является при этом регулярным аргументом (он даже за скобками), 
# поэтому вызов этого метода с любым другим аргументом, кроме блока кода, приведет к ошибке ArgumentError. 
# Поэтому нужен амперсанд перед названием переменной, чтобы руби понимал, 
# что передается блок (в формате, который представлен ниже). 
# Обычно такой метод передачи блока не используют (редко вижу в коде), но можно и так. 
# Пример:

[1, 2, 3].each_explicit() { |n| puts n }

def each_explicit(&block)
  return to_enum(:each) unless block
 
  i = 0
  while i < size
    block.call at(i)
    i += 1
  end
end

И третий вариант передачи блока кода в метод:
Инстанциировать объект класса Proc заранее, сохранив его в переменную. Тогда эту переменную можно передать в метод, как и любую другую переменную:

def run_proc_with_random_number(proc)
  proc.call(random)
end
 
proc = Proc.new { |n| puts "#{n}!" }
run_proc_with_random_number(proc)

Таким образом мы не передаем блок кода в стандартной нотации (так: .each() { |n| puts n } - заметьте, как я вынес {} за скобки.), а просто как обычный объект в обычную переменную.

Что использовать - решать вам. Соглашусь, что все это кажется излишним, и можно было бы обойтись чем-то одним, но иногда создание объекта из блока кода играет на руку.
