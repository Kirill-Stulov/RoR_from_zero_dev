# для того чтобы в методе вызвать блок - сущ несколько способов. 
# 1. СПОСОБ - Самый простой - метод yeild. Он вызывает переданный блок
  # Пример:
  def m
    puts "before block"
    yield                       # выходим из области метода и попадаем в блок через yield
    puts "after block"
  end

  # если вызвать этот метод и передать ему блок, то в строке 6 когда будет вызван yeild - будет исполнен блок
  # https://thinknetica.teachbase.ru/viewer/sessions/419154/materials/173827 21:00
  # c:\Users\kirill.stulov\Desktop\OctoberCutover_Back\TEMPO\1. Ruby on Rails c нуля (2015) [Базовый]\Занятие 07. Блоки, Proc и lambda\ 21:00

  #m  # если вызвать метод без блока то вылетит ошибка, т.к есть вызов yield в методе. Когда туда попадает управление - оно прыгает в блок => `m': no block given (yield) (LocalJumpError)

  m { puts "Inside block" } # теперь передаем блок. 
  # результат:
  # before block  строка из метода
  # Inside block  строка из блока
  # after block   снова строка из метода

  # В этом случае блок передается не как именованный аргумент в (). Нельзя заключить блок в круглые скобки.
  # ЕСЛИ В БЛОК НУЖНО ПЕРЕДАВАТЬ КАКИЕ-ТО ЗНАЧЕНИЯ ТО ДЕЛАЕТСЯ ТАК: 
  # Пример:
  # метод caps - пишет строку с заглавной буквы. У него будет аргумент str 
  def caps(str)  
    str.capitalize!   # он переводит строку в строку с заглавной буквы и передает дальше эту строку в блок  22:57
    yield(str)        # вызываем yield и передаем произвольное кол-во аргументов, эти аргументы попадут в блок
  end

  caps('stars') { |st| puts st[0] }    # вызов выглядит так - первым параметром передаем аргумент метода 'stars', дальше передаем блок {}, блок в данном примере выводит первую букву строки stars и она становится заглавной
  
  # ТЕПЕРЬ ПЕРЕПИШЕМ БЛОК ТАК ЧТОБЫ ОН ПРИНИМАЛ ИМЕНОВАННЫЙ АРГУМЕНТ (в данном примере -  block)
  def caps(str, block)
    str.capitalize!    
    block.call(str)    # дальше передаем блок как объект. Вызываем на нем метод call и передаем ему объект str 25:00
  end
  # В ЭТОМ СЛУЧАЕ МЕТОД caps ВЫЗЫВАЕТСЯ ТАК:
  block = lambda { |x| puts x }   # создаем переменную, которая содержит блок, например через lambda (про lambda и остальные способы создания блока - читай тут: 3_ways_to_create_proc.rb)
  # ВЫЗЫВАЕМ МЕТОД caps СЛЕДУЮЩИМ ОБРАЗОМ:
  caps 'stars', block             # первый аргумент - сама строка, дальше передаем блок
  # МНОГОСТРОЧНЫЙ lambda БЛОК ВЫГЛЯДИ ТАК:
  l = lambda do |a, b|
    tmp = a * 7
    tmp * b / 50
  end
    # Пример правильного стиля кода для многострочного блока:
    trains_block = lambda do |stats|                                                                           # создаем переменную, которая содержит блок, например через lambda (метод короткой однострочной записи лямбды смотри в how_to_write_functions_which_accepts_block.rb и в примере ниже). В блоке передаем переменную stats, которая содержит массив станций, перебираем его и для каждой станции 
      stats.each do |stat|                                                                                         # перебираем его (stats) и для каждой станции
        puts "Station:#{stat.name}"                                                                                                            # выводим имя станции в первой строке
        stat.trains.map { |train| puts "-> Train ##{train.number}; Type:#{train.type}; Vagons:#{train.wagons.length}" }                          # и во второй строке - список поездов в формате: Номер поезда, тип, кол-во вагонов
      end
    end



  # Реальный пример: метод self.each_train_on_station в station.rb,  и его вызов с блоком в interface.rb (\PROGS\tmp\oop_basics\Task_7\depot\station.rb; interface.rb)


# 2. СПОСОБ задания блока как аргумента метода. - В этом случае блок в списке аргументов должен быть последним и оно начинается с &. (Если нужен блок как именованный аргумент и при этом нужен обычный нормальный синтаксис )
  # Пример:
  def cap(str, &block)      # когда в чьем-либо коде видим аргумент со знаком амперcанд &, это означает что последний аргумент - этот блок
    str.capitalize!
    block.call(str)         # дальше передаем блок как объект. Вызываем на нем метод call и передаем ему объект str 26:55
  end

  # в этом случае можем вызывать метод cap (в котором у нас есть именованный аргумент, начинающийся с &) стандартным способом:  27:10
  cap('nemesis') { |x| puts x }   # передаем аргумент, затем блок


# 3. СПОСОБ записи блоков через lambda, это оператор ->:          
  # Запись:
    ->(x) { puts x }
    # это то же самое, что и
    lambda { |x| puts x }
    # только короче.
    # Если встретите такую запись, не пугайтесь, это всего лишь lambda.
    # Этот способ стоит использовать только для однострочного lambda блока!! НО! Можно писать и многострочный варинт, он будет еще и лаконичнее
    Пример многострочного lambda блока через ->
    trains_block = ->(stats) {                                                                                                # создаем переменную, которая содержит блок, например через lambda (метод такой записи лямбды смотри в how_to_write_functions_which_accepts_block.rb На самом деле - это однострочный вариант, но можно использовать и для многострочности). В блоке передаем переменную stats, которая содержит массив станций, перебираем его и для каждой станции
      stats.each do |stat|                                                                                       
        puts "Station:#{stat.name}"                                                                                                            # выводим имя станции в первой строке
        stat.trains.map { |train| puts "-> Train ##{train.number}; Type:#{train.type}; Vagons:#{train.wagons.length}" }                          # и во второй строке - список поездов в формате: Номер поезда, тип, кол-во вагонов
      end
    } 
  
  # КОГДА КАКОЙ СПОСОБ ИСПОЛЬЗУЮТ:
  #   Чаще всего используют именованную переменную.
  #   Если пишем свой метод, то чаще всего будем использвать yield
  #   Для различных библиотечных функций, для более сложного когда - чаще всего используется блок как именованная переменная. 
  #     Потому что нужно иметь доступ к объекту блока, он передается как proc - это значит что мы можем узнать различную информацию о блоке 
  #     - например один он принимает аргумент или несколько 
  #  !! Если в методе есть именованный аргумент блока, то yield будет вызывать также этот блок  28:50
  #     Пример:
      def cap(str, &block)      
        str.capitalize!
        block.call(str)         # также как раньше взываем на блоке метод call
        yield(str)               # и еще вызываем yield. В данном случае yield вызовет тот же самый блок
      end

      # И при вызове метода cap блок будет исполнен два раза
      cap('nemesis') { |x| puts x } 
        # Результат:
        # => Nemesis
        #    Nemesis

  # !!Когда пишем методы с блоками - бывают ситуации когда блок опциональный и нужно определить - передан блок или нет. Т.е метод опционально принимает блок. 29:30
      # И если блок не передан - то выполнить какую-либо дефолтную операцию
      # Если блок передан - то выполнить его
      # В этом случае внутри метода используется метод block_given? который определяет передан блок в метод или нет
      # Пример:
      def m(str, &block)      # некий метод которы принимает строку, именованный блок
        if block_given?       # и если блок передан, то метод предает эту строку в блок, а если не передан, то он его выводит. block_given? вернет true если методу передан блок
          yield(str)          # дальше просто вызываем yield(str) и передаем первый параметр, либо можно было сделать block.call(str)
        else                  # если же этот метод возвращает false, 
          puts str            # то просто выводим этот аргумент 
        end
      end

      m('croaton')                                 # теперь если передаем методу один параметр и не передаем блок, ошибки нет и просто выводится сама строка - выполняется puts 31:06
      m('croaton') { |x| x.capitalize!; puts x }  # если передаем вместе со строкой блок (в блоке приводим строку к строке с заглавной буквы x.capitalize! и выводим строку puts x), то испоняться будет уже блок
      # тоже самое будет работать и без именованного блока, т.е когда мы просто объявляем метод, аргументы и просто вызываем yield, block_given? работает универсально

      # Это все что нужно знать о блоках, что это такое, как они могут задаваться, как писать методы с использованием блоков
      # Главное что нужно знать, блоки - это очень мощная концепция, позволяющая динамически исполнять код, который можно отпределить в одном месте и передать в другое,
      # если использовать proc или lambda.
      # Либо можно просто динамически перебирать массивы, читать файлы и пр.  32:00
      # Делать большое кол-во вещей, где блоки передаются как аргумент и в нужном месте метода вызываются
      # соответственно управление передается в блок, блок исполняется, завершается, испольнение опять передается в тот метод
      # в который мы передавали этот блок.
      # !!Нужно отработать на практике написание методов, которые принимают блок.

      # *********************************************************************************************************
      # ПРИМЕРЫ!
      # Примеры использования блоков: PROGS\tmp\oop_basics\Task_7\depot\interface and station.rb and train.rb
                # Закоментированный вариант метода all_stations_details принимает массив и блок, оставляю как пример.  
          # # метод перебирает последовательно все станции и для каждой станции выводит список поездов в формате:
          #   # - Номер поезда, тип, кол-во вагонов 
          #   # Это как пункт 8 (метод show_stations_and_trains) - но вместо выбора станции - выдает сразу все существующие станции
          #   def all_stations_details        
          #     puts '######## All stations with trains in details: ########' 
          #     # !!ниже - правильный вариант записи блока согласно стилю оформления кода   
          #     trains_block = lambda do |stats|                                                                           # создаем переменную, которая содержит блок, например через lambda (метод короткой однострочной записи лямбды смотри в how_to_write_functions_which_accepts_block.rb и в примере ниже). В блоке передаем переменную stats, которая содержит массив станций, перебираем его и для каждой станции 
          #       stats.each do |stat|                                                                                         # перебираем его (stats) и для каждой станции
          #         puts "Station:#{stat.name}"                                                                                                            # выводим имя станции в первой строке
          #         stat.trains.map { |train| puts "-> Train ##{train.number}; Type:#{train.type}; Vagons:#{train.wagons.length}" }                          # и во второй строке - список поездов в формате: Номер поезда, тип, кол-во вагонов
          #       end
          #     end
          #     Station.stations_details(@stations, trains_block)                                                                       # вызываем метод класса station_details и передаем ему массив станций и блок для вывода данных о поездах на станции
          #   end 

          # def all_stations_details        
          #   puts '######## All stations with trains in details: ########'    
          #   !!ниже - неправильный вариант записи блока согласно стилю оформления кода, но более лаконичный, оставлю закоментированным
          #   trains_block = ->(stats) {                                                                                                # создаем переменную, которая содержит блок, например через lambda (метод такой записи лямбды смотри в how_to_write_functions_which_accepts_block.rb На самом деле - это однострочный вариант, но можно использовать и для многострочности). В блоке передаем переменную stats, которая содержит массив станций, перебираем его и для каждой станции
          #     stats.each do |stat|                                                                                       
          #       puts "Station:#{stat.name}"                                                                                                            # выводим имя станции в первой строке
          #       stat.trains.map { |train| puts "-> Train ##{train.number}; Type:#{train.type}; Vagons:#{train.wagons.length}" }                          # и во второй строке - список поездов в формате: Номер поезда, тип, кол-во вагонов
          #     end
          #    }
          #   Station.stations_details(@stations, trains_block)                                                                       # вызываем метод класса station_details и передаем ему массив станций и блок для вывода данных о поездах на станции
          # end


                  # Закоментированный вариант метода all_trains_details принимает массив и блок, оставляю как пример.
          # #  метод для каждого поезда на станции выводит список вагонов в формате:
          #   # номер вагона, тип вагона, кол-во свободных и занятых мест (для пассажирского вагона) или кол-во свободного и занятого объема (для грузовых вагонов).
          # def all_trains_details  
          #   puts '######## Wagons of each train in details: ########'
          #   vagons_block = lambda do |vags|                                         # создаем блок через lambda. тот-же вариант что и trains_block
          #     vags.each do |vag|
          #       case vag.type
          #       when :passenger                          
          #         puts "--> Wagon number:#{vag.number}; type:#{vag.type}; occupied_seats:#{vag.show_occupied_seats}; free_seats:#{vag.show_free_seats} "
          #       when :cargo
          #         puts "--> Wagon number:#{vag.number}; type:#{vag.type}; occupied_volume:#{vag.show_occupied_volume}; free_volume:#{vag.show_free_volume} "                      
          #       end
          #     end
          #   end

          #   Station.stations.each do |st|                                         # проходим по каждой станции
          #     puts "Station:#{st.name}"
          #     st.trains.each do |tr|                                                  # внутри каждой станции проходим по каждому поезду
          #       puts "-> Train ##{tr.number}"
          #       tr.train_details(@wagons, vagons_block)                                 # и на каждом поезде вызываем метод train_details, передаем ему вагоны и блок vagons_block
          #     # st.trains.each { |tr| tr.train_details(@wagons, vagons_block) }         # однострочный вариант- внутри каждой станции проходим по каждому поезду и на каждом поезде вызываем метод train_details, передаем ему вагоны и блок vagons_block
          #     end
          #   end
          # end
